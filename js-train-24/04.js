console.log("Завдання: 4 ==============================");

// Функція task4, яка буде використовувати проміси
function task4() {
  function promise1() {
    return new Promise(function executor(resolve, reject) {
      setTimeout(() => {
        resolve("Проміс 1 виконано");
      }, 1000);
    });
  }
  function promise2() {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        reject("Проміс 2 виконано");
      }, 2000);
    });
  }
  const test = Promise.all([promise1, promise2]);
  test
    .then((data) => {
      console.log(data);
    })
    .catch((err) => {
      console.log(err);
    })
    .finally(() => {
      console.log("Завдання 4 завершено");
    });
  // Визначаємо другий проміс з іменем promise2
  // Функція promise2, повертає новий проміс
  // Використовуємо функцію setTimeout, щоб симулювати асинхронну операцію з затримкою 1сек
  // Після 1 секунди викликаємо функцію resolve, яка змінює стан проміса на "виконано" і передає значення 'Проміс 2 виконано'
  // Promise.all приймає масив промісів і повертає новий проміс, який вирішується, коли всі вхідні проміси вирішені
  // Функція then викликається, коли проміс вирішений
  // Результати всіх вхідних промісів передаються у функцію then у вигляді масиву, виводимо в консоль масив
  // ['Проміс 1 виконано', 'Проміс 2 виконано']
  // Функція catch викликається, коли будь-який з промісів відхилено
  // Повідомлення про помилку від першого відхиленого проміса передається у функцію catch, виводимо в консоль помилку
  // Функція finally викликається незалежно від того, чи вирішено проміс, чи відхилено
  // Виводимо в консоль "Всі операції завершено"
}

// Викликаємо функцію task4
task4();
